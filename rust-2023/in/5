(define s (lambda (x) (lambda (y) (lambda (z) ((x z) (y z))))))
(define k (lambda (x) (lambda (y) x)))
(print "ans = 123")
(print (((s k) k) 123))

(print "ans = 15")
(define (fold-left f a l)
     (if (null? l) a
           (fold-left f (f a (car l)) (cdr l))))
(print (fold-left + 0 '(1 2 3 4 5)))

(define gen-counter
 	(lambda (start)
 		(define v start)
 		(lambda (b) (set! v (+ v 1)) v)))
(define c0up (gen-counter 0))
(define c1up (gen-counter 0))
(print "ans = 1, 2, 1, 3 ")
(print (c0up 0))
(print (c0up 0) )
(print (c1up 0))
(print(c0up 0))

(print (cons 1 (cons (cons 2 (cons "A" "B")) (cons 3 4))))

(define l (cons 1 (cons 3 ())))
(set-cdr! (cdr l) l)
(print "ans = 2")
(print (-  (car (cdr (cdr (cdr (cdr (cdr l))))))
     (car (cdr (cdr l)))))


 (define (solve H g)
   (define (in? x xl)
     (cond ((null? xl) #f)
           ((eq? x (car xl)) #t)
           (else (in? x (cdr xl)))))
   (define (solve-i g gl hl)
     (cond ((null? hl) #f)
           ((eq? (caar hl) g)
            (or (solve-i2 (cdar hl) (cons g gl))
                (solve-i g gl (cdr hl))))
           (else (solve-i g gl (cdr hl)))))

   (define (solve-i2 gs gl)
     (cond ((null? gs) #t)
           ((in? (car gs) gl) #f)
           (else
            (and (solve-i (car gs) gl H)
                 (solve-i2 (cdr gs) gl)))))
   (solve-i g '() H))
 (define env1 '((C B A) (B A) (A)))
 (define env2 '((A B) (A C) (A D) (B C) (D C) (D)))

(print "ans = #t, #t, #f, #t, #f")
(print (solve env1 'B))
(print (solve env1 'C)) 
(print (solve env1 'D)) 
(print (solve env2 'A))
(print (solve env2 'B))
(define f (lambda (f) (set! f (+ f 1)) f))
(print "ans = 1,3")
(print (f 0))
(print (f 2))